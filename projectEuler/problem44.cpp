/*
Pentagonal numbers are generated by the formula, P_n=n(3n-1)/2. The
first ten pentagonal numbers are:

1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...

It can be seen that P_4 + P_7 = 22 + 70 = 92 = P_8. However, their
difference, 70 - 22 = 48, is not pentagonal.

Find the pair of pentagonal numbers, P_j and P_k, for which their sum
and difference is pentagonal and D = |P_k - P_j| is minimised; what is
the value of D?

P_k - P_j = P_m, for some m < k < j
P_k + P_j = P_n, for some     k < j < n

k(3k-1) - j(3j-1) = m(3m-1)

k(3k-1) + j(3j-1) = n(3n-1)

*/

#include <iostream>
#include <set>
#include <stdlib.h>

using namespace std;

class Pentagonals
{
public:
  Pentagonals(int n); // initialize set up to P(n)
  bool isPentagonal( long long m );
  long long P(long long n);
private:
  set<long long> m_pentagonal_numbers;
  long long m_max;
};

bool Pentagonals::isPentagonal(long long m)
{
  set<long long>::const_iterator it = m_pentagonal_numbers.find(m);
  if ( it == m_pentagonal_numbers.end() ) {
    if ( m > m_max ) {
      // grow the set
      cout << "set is too small - size = " << m_pentagonal_numbers.size() << " to find " << m << endl;
    } else {
      // cout << m << " is not pentagonal" << endl;
    }
  } else {
    return true;
  }
}

long long Pentagonals::P(long long n)
{
  long long x = n*(3*n-1)/2;
  m_max = max(m_max, x);
  m_pentagonal_numbers.insert(x);
  return x;
}

Pentagonals::Pentagonals(int n)
{
  for (int i = 1; i <= n; ++i) {
    P(i);
  }
}

int main( int argc, char* argv[] )
{
  int limit = 10;
  if ( argc > 1 ) {
    limit = atoi(argv[1]);
  }
  /*
    walk the 2x2 half-quadrant {1 < k, k < j} diagonally

    k,j
        1,2 1,3 1,4 1,5 ...
            2,3 2,4 2,5 ...
	        3,4 3,5 ...
		    4,5 ...
  */

  // initialize all the pentagonal numbers up to P_limit
  Pentagonals p(limit);

  for ( long long j = 2; ; ++j ) {
    for ( long long k = 1; k < j; ++k ) {
      long long P_j = p.P(j), P_k = p.P(k);
      if ( p.isPentagonal(P_j - P_k) && p.isPentagonal(P_j + P_k) ) {
	cout << P_j - P_k << endl;
	return 0;
      }
    }
  }
  return 0;
}
